package com.small.library.data;

import java.util.*;
import java.sql.*;

/***************************************************************************************
*
*	Parent class for collection objects that contain zero to many DataRecord
*	object.
*	@author Xpedior\David Small
*	@version 1.0.0.0
*	@date 2/10/2000
*
***************************************************************************************/

public abstract class DataCollection
{
	/******************************************************************************
	*
	* Constructors/Destructor
	*
	******************************************************************************/

	/** Constructs the data collection object. */
	protected DataCollection() {}

	/** Constructs the data collection and supplies a JDBC connection object.
		@param pConnection A reference to a JDBC connection object.
	*/
	protected DataCollection(Connection pConnection) { setConnection(pConnection); }

	/******************************************************************************
	*
	* Main functionality
	*
	******************************************************************************/

	/** Loads the data collection with data records based on the subclasses
	    getResultSet functionality.
		@param pConnection A reference to the JDBC connection object to use.
		@param bReset Indicates whether to reset the data collection first.
	*/
	public void load(Connection pConnection, boolean bReset) throws SQLException
	{
		setConnection(pConnection);
		if (bReset) reset();

		ResultSet pResultSet = getResultSet();

		// If the result set is null, then do perform the load.
		if (null == pResultSet)
			return;

		while (pResultSet.next())
		{
			DataRecord pRecord = newRecord();
			pRecord.fetch(pResultSet);

			// Base class can implement "acceptRecord" to throw out
			// records it doesn't want.
			if (acceptRecord(pRecord))
				addItem(pRecord);
		}

		pResultSet.close();
	}

	/** Loads the data collection with data records based on the subclasses
	    getResultSet functionality.
		@param pConnection A reference to the JDBC connection object to use.
	*/
	public void load(Connection pConnection) throws SQLException
	{ load(pConnection, true); }

	/** Loads a <I>DataRecord</I> object with additional information
	    about a record that was not retrieved during the normal fetch. This
	    may include larger data fields such as long character or binary data.
		@param pRecord A <I>DataRecord</I> object.
	*/
	public void loadMore(DataRecord pRecord) throws SQLException
	{ pRecord.fetchMore(getResultSet(pRecord)); }

	/** Stores an indivdual data record in the data collection.
		@param pRecord A reference to a data record to store.
	*/
	public void store(DataRecord pRecord) throws SQLException
	{
		pRecord.update(prepareUpdateStatement());

		// Also, store the record in the same location in case
		// the record is a cloned version.
		setItem(pRecord);
	}

	/** Stores all the dirty data record objects in the collection. */
	public void store() throws SQLException
	{
		PreparedStatement pStmt = prepareUpdateStatement();
 
		for (int i = 0; i < m_Data.size(); i++)
			item(i).update(pStmt);
	}

	/** Only persists a new data record. It does not add the data record to the collection.
		@param pRecord The data record to add to the persistent storage.
	*/
	public void insertRecord(DataRecord pRecord) throws SQLException
	{ insertRecord(prepareInsertStatement(), pRecord); }

	/** Only persists a new data record. It does not add the data record to the collection.
		@param pStmt A Prepared Statement object for inserting the record.
		@param pRecord The data record to add to the persistent storage.
	*/
	public void insertRecord(PreparedStatement pStmt,
		DataRecord pRecord) throws SQLException
	{ pRecord.insert(pStmt); }

	/** Adds a new data record object to the data collection.
		@param pRecord A reference to a data record to add to the data collection.
	*/
	public DataRecord add(DataRecord pRecord) throws SQLException
	{
		insertRecord(pRecord);
		addItem(pRecord);

		return pRecord;
	}

	/** Adds all the data records in the List object to the data collection.
		@param pRecords A reference to the List interface of data record objects to add
		                to the data collection.
		@return Returns the number of records added.
	*/
	public int add(List pRecords) throws SQLException
	{
		int nSize = pRecords.size();
		PreparedStatement pStmt = prepareInsertStatement();

		for (int i = 0; i < nSize; i++)
		{
			DataRecord pRecord = (DataRecord) pRecords.get(i);
			insertRecord(pStmt, pRecord);
			addItem(pRecord);
		}

		return nSize;
	}

	/** Adds all the data records in the Vector object to the data collection.
		@param pRecords A reference to the vector of data record objects to add
		                to the data collection.
		@return Returns the number of records added.
	*/
	public int add(Vector pRecords) throws SQLException
	{
		int nSize = pRecords.size();
		PreparedStatement pStmt = prepareInsertStatement();

		for (int i = 0; i < nSize; i++)
		{
			DataRecord pRecord = (DataRecord) pRecords.elementAt(i);
			insertRecord(pStmt, pRecord);
			addItem(pRecord);
		}

		return nSize;
	}

	/** Removes a data record object from the data collection.
		@param pRecord A reference to a data record object to remove from the data collection.
	*/
	public void remove(DataRecord pRecord) throws SQLException
	{
		pRecord.delete(prepareDeleteStatement());
		removeItem(pRecord);
	}

	/** Removes all the data record objects from the data collection and physical database. */
	public void clear() throws SQLException
	{
		deleteAll();
		reset();
	}

	/** Determines if a data record already exists in the data collection.
		@param pRecord A reference to a data record object to check for duplication.
		@return Returns true if the data record already exists in the data collection.
	*/
	public boolean isDuplicate(DataRecord pRecord) throws SQLException
	{
		CallableStatement pStmt = prepareDuplicateStatement();

		pStmt.registerOutParameter(1, Types.INTEGER);
		pRecord.bindDesc(pStmt, pRecord.bindID(pStmt, 2));

		// Execute the statement.
		pStmt.executeUpdate();

		// Test for zero (0), because the return value can be
		// any number greater than zero, if true.
		return ((0 == pStmt.getInt(1)) ? false : true);
	}

	/** Determines if a data record can be removed from the database.
		@param pRecord A reference to a data record object to for removal.
		@return Returns true if the data record can be removed from the data collection.
	*/
	public boolean canRemove(DataRecord pRecord) throws SQLException
	{
		CallableStatement pStmt = prepareCanRemoveStatement();

		pStmt.registerOutParameter(1, Types.INTEGER);
		pRecord.bindID(pStmt, 2);

		// Execute the statement.
		pStmt.executeUpdate();

		// Test for zero (0), because the return value can be
		// any number greater than zero, if true.
		return ((0 == pStmt.getInt(1)) ? false : true);
	}

	/** Loops through the data record objects in the collection and polls for
	    a dirty record. A data record object is dirty if the data it contains
	    is inconsistent with the physical database.
		@return Returns true if a single data record object is dirty.
	*/
	public boolean isDirty()
	{
		for (int i = 0; i < m_Data.size(); i++)
			if (item(i).isDirty())
				return true;

		return false;
	}

	/** Returns the number of data record objects in the data collection. */
	public int size() { return m_Data.size(); }

	/** Returns a reference to a data record object at the index value in the
	    data collection.
		@param nItem The index value of the data record object in the data collection.
	*/
	public DataRecord item(int nItem) { return (DataRecord) m_Data.get(nItem);	}

	/** Returns a reference to a data record object that matches the key parameter.
		@param strKey A reference to a string key value.
	*/
	public DataRecord find(String strKey)
	{
		Integer i = (Integer) m_Map.get(strKey);

		if (i == null) return null;

		return (DataRecord) m_Data.get(i.intValue());
	}

	/** Returns whether a data record object matching the key parameter exists
	    in the data collection.
		@param strKey A reference to a string key value.
	*/
	public boolean exists(String strKey) { return m_Map.containsKey(strKey); }

	/******************************************************************************
	*
	* Functionality to be implemented by the subclass
	*
	******************************************************************************/

	/** Returns a reference to a new data record object appropriate the subclassed
	    data collection object. */
	public abstract DataRecord newRecord();

	/** Returns <CODE>true</CODE> to indicate that the record should be accepted into
	    the data collection during a load. The default implementation returns <CODE>true</CODE>.
	*/
	protected boolean acceptRecord(DataRecord pRecord) { return true; }

	/** Returns a reference to a JDBC resultset object for loading the
	    data record objects. */
	protected ResultSet getResultSet() throws SQLException { return null; }

	/** Returns a JDBC resultset object that retrieves additional information
	    about a record that was not retrieved during the normal fetch. This
	    may include larger data fields such as long character or binary data.
		@param pRecord A <I>DataRecord</I> object.
	*/
	protected ResultSet getResultSet(DataRecord pRecord) throws SQLException { return null; }

	/** Returns a reference to a JDBC prepared statement object for
	    performing updates of existing database records. */
	protected PreparedStatement prepareUpdateStatement() throws SQLException { return null; }

	/** Returns a reference to a JDBC prepared statement object for
	    performing inserts of new database records. */
	protected PreparedStatement prepareInsertStatement() throws SQLException { return null; }

	/** Returns a reference to a JDBC prepared statement object for
	    performing deletes against existing database records. */
	protected PreparedStatement prepareDeleteStatement() throws SQLException { return null; }

	/** Removes all records in the database matching the records in the data collection. */
	protected void deleteAll() throws SQLException {}

	/** Returns a reference to a JDBC callable statement object for
	    determining the duplicate status of a data record object. */
	protected CallableStatement prepareDuplicateStatement() throws SQLException { return null; }

	/** Returns a reference to a JDBC callable statement object for
	    determining the removable status of a data record object. */
	protected CallableStatement prepareCanRemoveStatement() throws SQLException { return null; }

	/******************************************************************************
	*
	* Accessor/Mutator methods
	*
	******************************************************************************/

	/** Returns a reference to the JDBC connection object in use. */
	public Connection getConnection() { return m_Connection; }

	/** Sets the JDBC connection object for use in the data collection.
		@param pConnection A reference to a JDBC connection object for use.
	*/
	public void setConnection(Connection pConnection) { m_Connection = pConnection; }

	/** Removes the reference to the JDBC connection object. */
	public void disconnect() { m_Connection = null; }

	/******************************************************************************
	*
	* Protected helper functions
	*
	******************************************************************************/

	/** Creates a JDBC ResultSet object based on the supplied statement.
		@param strStatement A SQL statement or stored procedure to prepare.
	*/
	protected ResultSet executeQuery(String strStatement) throws SQLException
	{
		if (null == strStatement) return null;

		return getConnection().createStatement().executeQuery(strStatement);
	}

	/** Creates a JDBC ResultSet object based on the supplied statement.
		@param strStatement A SQL statement or stored procedure to prepare.
	*/
	protected int executeUpdate(String strStatement) throws SQLException
	{
		if (null == strStatement) return 0;

		return getConnection().createStatement().executeUpdate(strStatement);
	}

	/** Creates a JDBC PreparedStatement object based on the supplied statement.
		@param strStatement A SQL statement or stored procedure to prepare.
	*/
	protected PreparedStatement prepareStatement(String strStatement)
		throws SQLException
	{
		if (null == strStatement) return null;

		return getConnection().prepareStatement(strStatement);
	}

	/** Creates a JDBC CallableStatement object based on the supplied statement.
		@param strStatement A SQL statement or stored procedure to prepare.
	*/
	protected CallableStatement prepareCall(String strStatement)
		throws SQLException
	{
		if (null == strStatement) return null;

		return getConnection().prepareCall(strStatement);
	}

	/******************************************************************************
	*
	* Private helper functions
	*
	******************************************************************************/

	/** Adds a new data record object to the in-memory collection. */
	private void addItem(DataRecord pRecord)
	{
		m_Data.add(pRecord);
		m_Map.put(pRecord.toString(), new Integer(m_Data.size() - 1));
	}

	/** Replaces the data record with a cloned version. Mainly used for stores. */
	private DataRecord setItem(DataRecord pRecord)
	{
		Integer i = (Integer) m_Map.get(pRecord.toString());

		if (null == i) return null;

		return (DataRecord) m_Data.set(i.intValue(), pRecord);
	}

	/** Removes all data record objects from the in-memory collection. */
	private void reset()
	{
		m_Data.clear();
		m_Map.clear();
	}

	/** Removes the item from both collections and compacts their order. */
	private void removeItem(DataRecord pRecord)
	{
		int nIndex = ((Integer)m_Map.get(pRecord.toString())).intValue();

		m_Data.remove(nIndex);
		m_Map.remove(pRecord.toString());

		// No need to compact.
		if (nIndex >= size())
			return;

		// Must decrement the Integer values that map to the array list.
		// This is going to be slow. Must devise new storage method is future.
		Enumeration pEnum = m_Map.keys();

		while (pEnum.hasMoreElements())
		{
			String strID = pEnum.nextElement().toString();
			Integer pIndex = (Integer) m_Map.get(strID);

			// Override previous value.
			if (nIndex < pIndex.intValue())
				m_Map.put(strID, new Integer(pIndex.intValue() - 1));
		}
	}

	/******************************************************************************
	*
	* Private member variables
	*
	******************************************************************************/

	private Connection m_Connection;
	private Hashtable m_Map = new Hashtable();
	private ArrayList m_Data = new ArrayList();
}
